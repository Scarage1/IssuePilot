"""
Utility functions for IssuePilot
"""
import re
import json
from typing import Dict, Any, List
from .schemas import AnalysisResult


def validate_repo_format(repo: str) -> bool:
    """
    Validate repository format (owner/repo)
    
    Args:
        repo: Repository string to validate
        
    Returns:
        True if valid, False otherwise
    """
    pattern = r"^[\w.-]+/[\w.-]+$"
    return bool(re.match(pattern, repo))


def parse_repo(repo: str) -> tuple:
    """
    Parse repository string into owner and repo name
    
    Args:
        repo: Repository string in format 'owner/repo'
        
    Returns:
        Tuple of (owner, repo_name)
    """
    parts = repo.split("/")
    if len(parts) != 2:
        raise ValueError(f"Invalid repo format: {repo}")
    return parts[0], parts[1]


def truncate_text(text: str, max_length: int = 4000) -> str:
    """
    Truncate text to a maximum length while preserving word boundaries
    
    Args:
        text: Text to truncate
        max_length: Maximum character length
        
    Returns:
        Truncated text
    """
    if len(text) <= max_length:
        return text
    
    truncated = text[:max_length]
    last_space = truncated.rfind(" ")
    if last_space > max_length * 0.8:
        truncated = truncated[:last_space]
    
    return truncated + "..."


def clean_json_response(response: str) -> Dict[str, Any]:
    """
    Clean and parse JSON from AI response
    
    Args:
        response: Raw response string from AI
        
    Returns:
        Parsed JSON dictionary
    """
    # Try to extract JSON from markdown code blocks
    json_match = re.search(r"```(?:json)?\s*([\s\S]*?)\s*```", response)
    if json_match:
        response = json_match.group(1)
    
    # Clean up common issues
    response = response.strip()
    
    try:
        return json.loads(response)
    except json.JSONDecodeError as e:
        raise ValueError(f"Failed to parse AI response as JSON: {e}")


def generate_markdown_export(analysis: AnalysisResult, repo: str = "", issue_number: int = 0) -> str:
    """
    Generate markdown export from analysis result
    
    Args:
        analysis: Analysis result to export
        repo: Repository name (optional)
        issue_number: Issue number (optional)
        
    Returns:
        Formatted markdown string
    """
    md_lines = ["# ðŸ” Issue Analysis Report", ""]
    
    if repo and issue_number:
        md_lines.extend([
            f"**Repository:** `{repo}`",
            f"**Issue:** #{issue_number}",
            ""
        ])
    
    md_lines.extend([
        "---",
        "",
        "## ðŸ“‹ Summary",
        "",
        analysis.summary,
        "",
        "---",
        "",
        "## ðŸ”¬ Root Cause Analysis",
        "",
        analysis.root_cause,
        "",
        "---",
        "",
        "## ðŸ› ï¸ Solution Steps",
        ""
    ])
    
    for i, step in enumerate(analysis.solution_steps, 1):
        md_lines.append(f"{i}. {step}")
    
    md_lines.extend([
        "",
        "---",
        "",
        "## âœ… Developer Checklist",
        ""
    ])
    
    for item in analysis.checklist:
        md_lines.append(f"- [ ] {item}")
    
    md_lines.extend([
        "",
        "---",
        "",
        "## ðŸ·ï¸ Suggested Labels",
        "",
        ", ".join([f"`{label}`" for label in analysis.labels]),
        ""
    ])
    
    if analysis.similar_issues:
        md_lines.extend([
            "---",
            "",
            "## ðŸ”— Similar Issues",
            ""
        ])
        for issue in analysis.similar_issues:
            md_lines.append(f"- [{issue.title}]({issue.url}) (Similarity: {issue.similarity:.0%})")
        md_lines.append("")
    
    md_lines.extend([
        "---",
        "",
        "*Generated by [IssuePilot](https://github.com/issuepilot/issuepilot) ðŸš€*"
    ])
    
    return "\n".join(md_lines)


def extract_code_blocks(text: str) -> List[Dict[str, str]]:
    """
    Extract code blocks from issue body
    
    Args:
        text: Text containing code blocks
        
    Returns:
        List of dicts with 'language' and 'code' keys
    """
    pattern = r"```(\w*)\n([\s\S]*?)```"
    matches = re.findall(pattern, text)
    
    return [{"language": lang or "text", "code": code.strip()} for lang, code in matches]


def sanitize_input(text: str) -> str:
    """
    Sanitize user input to prevent injection attacks
    
    Args:
        text: Text to sanitize
        
    Returns:
        Sanitized text
    """
    if not text:
        return ""
    
    # Remove null bytes
    text = text.replace("\x00", "")
    
    # Limit length
    max_length = 50000
    if len(text) > max_length:
        text = text[:max_length]
    
    return text
